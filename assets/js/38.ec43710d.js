(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{319:function(v,_,a){"use strict";a.r(_);var s=a(14),t=Object(s.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"java八股技术面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java八股技术面"}},[v._v("#")]),v._v(" Java八股技术面")]),v._v(" "),_("blockquote",[_("p",[v._v("参照个人的简历准备的面试资料")])]),v._v(" "),_("p",[v._v("Java基础：熟悉Java面向对象，能够利用Java8新特性优化代码，阅读过集合类源码，有良好的开发规范")]),v._v(" "),_("p",[v._v("并发编程：熟悉Java并发编程，了解Java中的线程和 “锁” 的使用，能够通过多线程优化业务代码执行速度")]),v._v(" "),_("p",[v._v("关系型数据库：熟悉 MySQL 和 SQL 语句的编写，掌握MySQL中的索引、事务、日志等常见知识")]),v._v(" "),_("p",[v._v("非关系型数据库：熟悉 Redis 的使用，能够通过Redis实现分布式锁、缓存，并了解Redis常见数据类型，能够 解决在高并发下的缓存穿透，击穿，雪崩问题")]),v._v(" "),_("p",[v._v("消息队列：熟悉RabbitMQ的基本用法，能够使用消息队列实现应用解构，流量削峰和业务的异步处理")]),v._v(" "),_("p",[v._v("开源框架：熟悉 Spring、Spring MVC、SpringBoot、MyBatis、MyBatis-Plus等主流开发框架 ，并且掌握 IOC ，AOP 等知识")]),v._v(" "),_("p",[v._v("云原生：熟悉 Docker 容器的基本命令的使用，了解 Dockerfile 和 docker-compose 的编写， 能够独立在 Linux服务器上部署前后端分离项目")]),v._v(" "),_("p",[v._v("开发工具：熟练使用 Maven、Git、IDEA、 Docker 等开发工具")]),v._v(" "),_("p",[v._v("前端技术：了解 HTML 、CSS 、JavaScript 、Axios ；熟悉 Vue 框架")]),v._v(" "),_("p",[v._v("面试官，您好！我叫xx。大学时间我主要利用课外时间学习了 Java 以及 Spring、MyBatis 等框架 。在校期间参与过一个考试系统的开发，这个系统的主要用了 Spring、MyBatis 和 shiro 这三种框架。我在其中主要担任后端开发，主要负责了权限管理功能模块的搭建。另外，我在大学的时候参加过一次软件编程大赛，我和我的团队做的在线订餐系统成功获得了第二名的成绩。我还利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 Github 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！")]),v._v(" "),_("h2",{attrs:{id:"redis篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis篇"}},[v._v("#")]),v._v(" Redis篇")]),v._v(" "),_("h3",{attrs:{id:"在你的项目中是怎么使用redis的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#在你的项目中是怎么使用redis的"}},[v._v("#")]),v._v(" 在你的项⽬中是怎么使⽤Redis的")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("在我的项⽬中使⽤ Redis 配合 Spring 的 Redis-session，将⽤户的登录态存⼊ Redis，实现单点登录。")])]),v._v(" "),_("li",[_("p",[v._v("对于系统的⾸⻚，为了加快响应速度，设置定时任务将⾸⻚数据缓存到 Redis中，避免了⾸⻚加载过慢⽤户体")])])]),v._v(" "),_("p",[v._v("验差的情况。")]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("对于⽤户加⼊队伍的限制，使⽤ Redisson 作分布式锁，防⽌了⽤户恶意请求加⼊超出限制数量的队伍。")])]),v._v(" "),_("h3",{attrs:{id:"介绍一下缓存穿透-以及如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下缓存穿透-以及如何解决"}},[v._v("#")]),v._v(" 介绍一下缓存穿透，以及如何解决")]),v._v(" "),_("p",[v._v("缓存穿透：用户发送请求查询某个队伍详细信息，正常情况下首先查询缓存，如果缓存中存在则直接返回数据，如果缓存中不存在，则会查询数据库，数据库中查询到数据之后写到缓存中然后返回数据，如果数据库中也没有该数据，就会发生缓存穿透，即所查询的数据缓存中不存在，数据库中也不存在，会出现大量的请求请求到数据库这就是缓存穿透。")]),v._v(" "),_("p",[v._v("解决：在我的项目中，我是使用缓存空值的方法来解决缓存穿透的问题，优点是实现起来简单，缺点是可能会造成短暂的缓存与数据不一致的情况。当查询数据库中没有数据的时候，我们先缓存Redis中该id为key缓存一个空字符串，然后一定要设置一个合理的过期时间，然后返回不存在数据；当请求再次来到的时候，首先检查到Redis中该id对应的缓存是空字符串，直接返回数据不存在。")]),v._v(" "),_("blockquote",[_("p",[v._v("还有一种我了解的解决方案是布隆过滤器，布隆过滤器主要是检查一个元素是否在一个集合中，可以使用redisson实现的布隆过滤器。")]),v._v(" "),_("p",[v._v("底层是先初始化一个比较大的数组，里面存放二进制的0和1，在一开始全都是0，当一个key来了之后经过3次hash计算，然后模数组的长度找到对应的下标，把下标该为1，这样3个数组的位置就能确定一个key是否存在。")]),v._v(" "),_("p",[v._v("缺点是可能存在误判，这个我们可以设置误判率，大概不超过5%。为什么会有误判？因为数组长度是固定的，当有一个key经过3次hash计算后模数组长度得到的3个下标对应的都是1的时候就会直接认为该数据存在，但是实际不存在。")])]),v._v(" "),_("h3",{attrs:{id:"什么是缓存击穿-如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存击穿-如何解决"}},[v._v("#")]),v._v(" 什么是缓存击穿，如何解决")]),v._v(" "),_("p",[v._v("缓存击穿：某个key设置了过期时间，当该key过期了，有大量的请求请求到该key，这些并发请求可能会瞬间把数据库压垮。")]),v._v(" "),_("p",[v._v("解决：我了解的有两种解决方案，分别是分布式锁，逻辑过期法。在项目中我使用分布式锁解决缓存击穿问题，具体方法是使用Redis的setnx关键字来实现分布式锁，首先大量的并发请求请求到一个key刚好在缓存中过期了，缓存中没有该数据则会请求数据库，在请求数据库之前使用Redis的setnx设置一个业务前缀：lock的key，如果有一个请求设置成功了，则其他的请求会再此处重试，我们让获取锁成功的去进行缓存重构，当然在缓存重构之前需要再次查询缓存是否存在数据，防止已经被其他线程缓存重构过了，完成之后需要手动删除该锁。要注意需要给lock设置一个合理的过期时间，防止出现死锁。这个过期时间需要根据具体的业务复杂度来设置，不能太短，防止业务还没有处理完毕就自动把锁释放了。")]),v._v(" "),_("p",[v._v("另一种是逻辑过期的方法解决缓存击穿，我们需要手动给热点key的数据中添加一个过期时间，在请求来到的时候，先查询缓存，然后检查缓存中的时间是否过期，如果没有过期则返回数据，如果已经过期，获取互斥锁，如果获取失败的直接先返回过期的数据，获取锁成功的线程执行缓存重构，同样在缓存重构之前需要进行二次校验判断是否被重构过了，如果没有重构则查询数据库更新逻辑过期时间和数据。")]),v._v(" "),_("h3",{attrs:{id:"什么是缓存雪崩-如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存雪崩-如何解决"}},[v._v("#")]),v._v(" 什么是缓存雪崩，如何解决")]),v._v(" "),_("p",[v._v("缓存雪崩：在同一时刻缓存中有大量的key同时过期或者Redis宕机，导致大量的请求打到数据库中，给数据库带来巨大的压力。")]),v._v(" "),_("p",[v._v("解决：给不同的key设置不同的过期时间，比如给不同的key设置一个固定的过期时间再加上一个随机的时间，这样就可以解决缓存同时过期的问题。如果Redis服务宕机可以设置Redis集群来提高Redis服务的可用性")]),v._v(" "),_("h3",{attrs:{id:"redis作为缓存-mysql的数据如何与redis数据保持一致性-双写一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis作为缓存-mysql的数据如何与redis数据保持一致性-双写一致性"}},[v._v("#")]),v._v(" Redis作为缓存，mysql的数据如何与Redis数据保持一致性(双写一致性)")]),v._v(" "),_("blockquote",[_("p",[v._v("首先要结合自己的项目业务来分析，一致性高的场景下是一种方案，一致性不高允许出现延迟的场景可以采用另一种方案")])]),v._v(" "),_("p",[v._v("双写一致性：当修改了数据库中的数据，也要同时更新缓存的数据，缓存的数据需要和数据库中的数据保持一致性。")]),v._v(" "),_("p",[v._v("在我的项目中，修改队伍信息是需要保证及时生效的，防止展示出来的还是原本的数据，可以采用"),_("strong",[v._v("延迟双删")]),v._v("的方案来保证双写一致性。在修改之前先删除一次缓存，修改成功后然后再延迟删除缓存，这样的好处是可以极大的减少缓存不一致的情况。")]),v._v(" "),_("p",[v._v("另外一种方案是读操作和写操作都"),_("strong",[v._v("加同一个分布式锁")]),v._v("，不过不太推荐这样做，因为保存到缓存中的数据都是读多写少的数据，这样做在大量请求的情况下会极大的影响到读的效率，可以使用"),_("strong",[v._v("redisson封装的共享锁(读锁)和排它锁(写锁)")]),v._v("，在读操作的前后加上共享锁，在写操作的前后加上排它锁，这样在读的时候其他线程是不可以写的但是可以读，在写的时候其他线程不允许读写数据；这样可以保证强一致性。")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("另一种是允许数据短暂的不一致，在我别的项目中，Redis缓存店铺信息，店铺信息允许出现短暂的数据不一致情况，我采用的是给缓存的店铺设置一个短一点过期时间，当修改的时候不需要操作缓存，我们只需要等待缓存数据过期然后进行缓存重构即可更新缓存数据。我了解的还有另外一种方式：在修改数据之后，通过消息队列MQ通知缓存更新的服务来删除对应的数据，保证数据一致性；"),_("strong",[v._v("这里需要保证MQ的消息可靠性")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"redis作为缓存-数据的持久化是怎么做的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis作为缓存-数据的持久化是怎么做的"}},[v._v("#")]),v._v(" Redis作为缓存，数据的持久化是怎么做的")]),v._v(" "),_("p",[v._v("在Redis中提供了两种持久化方案：RDB、AOF")]),v._v(" "),_("p",[v._v("RDB：把内存中的所有数据都记录到磁盘中。当Redis出现故障重启后，可以从磁盘中读取该RDB文件，恢复数据。")]),v._v(" "),_("p",[v._v("1.在Redis客户端中使用save可以在主进程中执行备份操作，不过会阻塞主进程，不推荐使用；另一种是使用bgsave，新开启一个子进程执行备份的操作。")]),v._v(" "),_("p",[v._v("2.也可以在Redis.conf文件中配置备份的触发条件例如save 300 10(300秒内如果有10个key修改了则触发备份，这里备份也是在子进程中执行的)")]),v._v(" "),_("p",[v._v("AOF：AOF全称Append Only File(追加文件)。Redis处理的"),_("strong",[v._v("每一个写的命令都会记录在AOF文件")]),v._v("，可以看做是命令日志文件。")]),v._v(" "),_("p",[v._v("AOF默认是关闭的需要我们到配置文件中手动开启:")]),v._v(" "),_("div",{staticClass:"language-sh extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sh"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 是否开启AOF功能，默认是no")]),v._v("\nappendonly "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("yes")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# AOF的文件的名称")]),v._v("\nappendfilename "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"appendonly.aof"')]),v._v("\n")])])]),_("p",[v._v("开启后可以配置AOF记录的频率：")]),v._v(" "),_("div",{staticClass:"language-sh extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sh"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 每执行一次命令，立即记录到AOF中")]),v._v("\nappendfsync always\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 写命令执行完毕先放入AOF缓冲区，然后每隔1秒将缓冲区的数据写入到AOF文件中，默认方案")]),v._v("\nappendfsync everysec\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 写命令执行完毕后先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写入AOF文件")]),v._v("\nappendfsync no\n")])])]),_("table",[_("thead",[_("tr",[_("th",[v._v("配置项")]),v._v(" "),_("th",[v._v("刷盘时机")]),v._v(" "),_("th",[v._v("优点")]),v._v(" "),_("th",[v._v("缺点")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("always")]),v._v(" "),_("td",[v._v("同步刷盘")]),v._v(" "),_("td",[v._v("可靠性高，几乎不丢失数据")]),v._v(" "),_("td",[v._v("性能影响大")])]),v._v(" "),_("tr",[_("td",[v._v("everysec")]),v._v(" "),_("td",[v._v("每秒刷盘")]),v._v(" "),_("td",[v._v("性能适中")]),v._v(" "),_("td",[v._v("最多丢失1秒的数据")])]),v._v(" "),_("tr",[_("td",[v._v("no")]),v._v(" "),_("td",[v._v("操作系统控制")]),v._v(" "),_("td",[v._v("性能最好")]),v._v(" "),_("td",[v._v("可靠性差，可能丢失大量的数据")])])])]),v._v(" "),_("p",[v._v("另外由于AOF记录的是命令序列，当我们对一个key进行多次的写操作的时候，最后一次会覆盖掉前面的例如")]),v._v(" "),_("div",{staticClass:"language-sh extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sh"}},[_("code",[_("span",{pre:!0,attrs:{class:"token builtin class-name"}},[v._v("set")]),v._v(" k1 v1\n"),_("span",{pre:!0,attrs:{class:"token builtin class-name"}},[v._v("set")]),v._v(" k2 v2\n"),_("span",{pre:!0,attrs:{class:"token builtin class-name"}},[v._v("set")]),v._v(" k1 v3\n")])])]),_("p",[v._v("k1的值就是v3了，但是AOF中还是记录了所有的操作，我们可以执行"),_("code",[v._v("bgrewriteaof")]),v._v("命令来让AOF执行重写来减少AOF文件的占用磁盘大小，重写后的如下：")]),v._v(" "),_("div",{staticClass:"language-sh extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sh"}},[_("code",[v._v("mset k2 v2 k1 v3\n")])])]),_("p",[v._v("总结：")]),v._v(" "),_("blockquote",[_("p",[v._v("RDB 适合⽤于"),_("strong",[v._v("数据集较⼤、备份、恢复数据和迁移数据")]),v._v("等场景；AOF 适合⽤于"),_("strong",[v._v("数据可靠性要求⾼、数据恢复稳健")]),v._v("等场景。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308231035950.png",alt:"image-20230823103515194"}})]),v._v(" "),_("h3",{attrs:{id:"redis数据过期策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis数据过期策略"}},[v._v("#")]),v._v(" Redis数据过期策略")]),v._v(" "),_("blockquote",[_("p",[v._v("引出：如果Redis的key过期后会立即删除吗？")]),v._v(" "),_("p",[_("code",[v._v("setex name jack 10")])]),v._v(" "),_("p",[v._v("数据过期之后就需要将数据从内存中删除，可以按照不同的规则删除，这种删除规则就称为数据的删除策略(数据过期策略)。惰性删除、定期删除")])]),v._v(" "),_("p",[v._v("惰性删除：设置一个key当该key过期的时候，我们不需要管他，当需要该key的时候我们在检查他是否过期，如果已经过期了我们就删除掉他，反之则返回该key的值")]),v._v(" "),_("p",[v._v("优点：对CPU友好，我们只会在使用key的时候进行检查该key是否过期了，对于很多用不到的key不需要浪费时间进行检查是否过期")]),v._v(" "),_("p",[v._v("缺点：对内存不友好，当大量的key都过期了，但是没有人访问他，那么这些key就会一直存在内存中从而占用大量的内存")]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("定期删除：每隔一段时间，我们就对一些key进行检查，删除里面过期的key。")]),v._v(" "),_("p",[v._v("定期清理有两种模式：SLOW模式和FAST模式。")]),v._v(" "),_("p",[v._v("优点：可以通过限制删除操作执行的时长和频率来减少删除操作对CPU的影响。定期删除能有效释放过期键占用的内存。")]),v._v(" "),_("p",[v._v("缺点：难以确定删除操作执行的时长和频率。")]),v._v(" "),_("blockquote",[_("p",[v._v("Redis的过期删除策略："),_("code",[v._v("惰性删除")]),v._v(" + "),_("code",[v._v("定期删除")]),v._v(" 两种策略进行配合使用")])]),v._v(" "),_("h3",{attrs:{id:"redis数据淘汰策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis数据淘汰策略"}},[v._v("#")]),v._v(" Redis数据淘汰策略")]),v._v(" "),_("p",[v._v("当Redis中内存不够用的时候，此时再向Redis中添加新的key的时候，那么Redis就会按照某一种规则将内存中的数据删除掉，这种删除规则称之为内存的淘汰策略。")]),v._v(" "),_("p",[v._v("Redis常用的淘汰策略：")]),v._v(" "),_("p",[v._v("noeviction：当内存打到限制时，不删除任何键，⽽是返回错误；")]),v._v(" "),_("p",[_("strong",[v._v("allkeys-lru")]),v._v("：当内存达到限制时，删除最近最少使⽤（LRU）的键；")]),v._v(" "),_("p",[v._v("volatile-lru：当内存达到限制时，删除设置了过期时间并且最近最少使⽤的键；")]),v._v(" "),_("p",[v._v("allkeys-random：当内存达到限制时，随机删除任意键；")]),v._v(" "),_("p",[v._v("volatile-random：当内存达到限制时，随机删除设置了过期时间的键；")]),v._v(" "),_("p",[v._v("volatile-ttl：当好内存达到限制时，删除设置了过期时间并且剩余⽣存时间最短的键。")]),v._v(" "),_("h3",{attrs:{id:"redis分布式锁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁"}},[v._v("#")]),v._v(" Redis分布式锁")]),v._v(" "),_("p",[v._v("Redis分布式锁主要利用Redis中的setnx来命令来实现。setnx命令是如果key不存在才能set对应的值，如果key存在了，则不能set对应的值")]),v._v(" "),_("p",[v._v("获取锁：")]),v._v(" "),_("p",[_("code",[v._v("set lock 1 nx ex 10")]),v._v(" # 添加锁，nx是互斥、ex是设置锁的失效时间")]),v._v(" "),_("p",[v._v("释放锁：")]),v._v(" "),_("p",[_("code",[v._v("DEL lock")]),v._v(" # 删除即可")]),v._v(" "),_("h3",{attrs:{id:"redis分布式锁如何合理的控制锁的有效时间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis分布式锁如何合理的控制锁的有效时间"}},[v._v("#")]),v._v(" Redis分布式锁如何合理的控制锁的有效时间")]),v._v(" "),_("p",[v._v("1.根据具体业务估计设置锁的时长。不太靠谱")]),v._v(" "),_("p",[v._v("2.给锁续期，新开一个线程监视业务是否执行完毕，如果没有执行完毕并且锁的ttl快到期了，则自动续期。我的项目中使用的是redisson第三方依赖中的锁，该锁自带了"),_("strong",[v._v("watchdog机制")]),v._v("可以自动续期。使用redisson加锁的时候，内部是通过Lua脚本进行实现的，可以保证命令的原子性。")]),v._v(" "),_("h3",{attrs:{id:"redisson的锁可以重入吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redisson的锁可以重入吗"}},[v._v("#")]),v._v(" Redisson的锁可以重入吗？")]),v._v(" "),_("blockquote",[_("p",[v._v("锁的重入：方法a中加了锁，方法b中也加了同一把锁，在方法a中调用方法b如果可以成功加锁，并且释放锁则是可重入锁")])]),v._v(" "),_("p",[v._v("Redisson的锁是可重入的锁，redisson锁根据线程唯一标识判断是否是同一个线程，如果线程相同，则是可以重入的，重入一次对应的value值+1。在redis中存储的时候使用hash数据类型，来存储线程信息和重入次数。")]),v._v(" "),_("h3",{attrs:{id:"redisson锁可以解决主从数据的一致问题吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redisson锁可以解决主从数据的一致问题吗"}},[v._v("#")]),v._v(" Redisson锁可以解决主从数据的一致问题吗")]),v._v(" "),_("p",[v._v("不能解决，但是可以使用redisson提供的红锁RedLock，原理是给(n/2)+1个节点设置锁，这样主节点宕机即使没有来得及同步从节点从节点中也是有锁的，从而避免只在一个redis实例上加锁。")]),v._v(" "),_("h3",{attrs:{id:"介绍redis的主从同步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍redis的主从同步"}},[v._v("#")]),v._v(" 介绍Redis的主从同步")]),v._v(" "),_("p",[v._v("单节点的Redis的并发能力是有限的，想要提高Redis的并发能力，我们可以搭建Redis集群，实现一个主节点和若干个从节点，主节点主要负责写数据，从节点负责读数据")]),v._v(" "),_("h3",{attrs:{id:"介绍一下redis中哨兵的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下redis中哨兵的作用"}},[v._v("#")]),v._v(" 介绍一下Redis中哨兵的作用")]),v._v(" "),_("p",[v._v("Redis提供了哨兵机制来实现Redis主从集群的自动故障恢复。")]),v._v(" "),_("p",[v._v("监控：哨兵会不断的检查你的master和slave是否按照预期工作。")]),v._v(" "),_("p",[v._v("故障自动恢复：如果master故障，哨兵会将一个slave提升为master。当故障恢复后还是以新提升的master位主节点")]),v._v(" "),_("p",[v._v("通知：哨兵充当Redis客户端的服务发现来源，当集群发送故障转移时，会将最新的消息推送给Redis的客户端")]),v._v(" "),_("p",[v._v("哨兵怎么监控Redis的服务状态的？")]),v._v(" "),_("p",[v._v("哨兵基于心跳机制检测服务的状态，每一秒向集群的每一台实例发送ping命令：")]),v._v(" "),_("p",[v._v("主观下线：如果哨兵发现某一台实例没有在规定的时间内响应，则认为该实例主观下线；")]),v._v(" "),_("p",[v._v("客观下线：如果超过指定数量的哨兵(哨兵有多个)都认为该实例主观下线，则该实例就是客观下线了。指定数量最好是超过哨兵数量的一半")]),v._v(" "),_("h3",{attrs:{id:"redis集群脑裂-该如何解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis集群脑裂-该如何解决"}},[v._v("#")]),v._v(" Redis集群脑裂，该如何解决")]),v._v(" "),_("p",[v._v("集群脑裂：是由于主节点由于自身的网络问题导致主节点和从节点以及sentinel处于不同的网络分区，导致sentinel不能感知到master，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，就像大脑分裂了一样，这样就会导致客户端还是在老的主节点那里写入数据，新选举出来的主节点无法同步数据，当网络恢复的时候，原来的那个老的主节点就变成了新选举出来的主节点的从节点，"),_("strong",[v._v("这时候从节点会同步主节点的数据，就会导致数据丢失")]),v._v("。")]),v._v(" "),_("p",[v._v("解决：由于脑裂是由网络等原因造成的，除了提高网络、硬件等方法外，主要通过增加以下配置，改善出现脑裂而引发的数据丢失问题。")]),v._v(" "),_("div",{staticClass:"language-sh extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sh"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 要求至少有1个slave")]),v._v("\nmin-slaves-to-write "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v(" \n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 数据复制和同步的延迟不能超过10秒")]),v._v("\nmin-slaves-max-lag "),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("10")]),v._v(" \n")])])]),_("h3",{attrs:{id:"分片集群解决海量数据的存储和高并发的写操作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分片集群解决海量数据的存储和高并发的写操作"}},[v._v("#")]),v._v(" 分片集群解决海量数据的存储和高并发的写操作")]),v._v(" "),_("p",[v._v("分片集群特征：")]),v._v(" "),_("p",[v._v("集群中有多个master，每个master保存不同的数据")]),v._v(" "),_("p",[v._v("每个master都可以有多个slave节点")]),v._v(" "),_("p",[v._v("master之间通过ping监测彼此的健康状态")]),v._v(" "),_("p",[v._v("客户端可以访问集群的任意节点，最终都会被转发到正确的节点")]),v._v(" "),_("blockquote",[_("p",[v._v("Redis分片集群中引入了哈希槽的概念，Redis集群有16384(2^14)个哈希槽，每个key通过"),_("strong",[v._v("CRC16")]),v._v("校验之后对16384取模来决定放入到哪个槽位，集群的每一个节点负责一部分的哈希槽。")])]),v._v(" "),_("h3",{attrs:{id:"redis是单线程的-但是为什么还那么快"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#redis是单线程的-但是为什么还那么快"}},[v._v("#")]),v._v(" Redis是单线程的，但是为什么还那么快？")]),v._v(" "),_("p",[v._v("1、纯内存操作\nRedis 是基于内存的数据存储系统，绝⼤部分请求是纯粹的内存操作。")]),v._v(" "),_("p",[v._v("2、单线程操作，避免了频繁的上下⽂切换\nRedis 的单线程操作是指，Redis 使⽤⼀个主线程来处理所有的客户端请求和数据操作，不会创建新的线程来处理请求。这种单线程模型的优点是可以避免多线程并发访问共享数据时的竞争和死锁问题，从⽽提⾼了 Redis 的性能和稳定性。此外，由于 Redis 的内存访问速度⾮常快，因此单线程处理请求也能够保证⾜够的性能。")]),v._v(" "),_("p",[v._v("3、采⽤了"),_("strong",[v._v("⾮阻塞 I/O 多路复⽤")]),v._v("机制\n为了实现单线程模型，Redis 使⽤了 IO 多路复⽤技术。IO 多路复⽤是指操作系统提供的⼀种 IO 模型，可以让⼀个进程同时监听多个 IO 事件（如读写事件），并在有事件发⽣时通知进程，从⽽实现并发处理 IO 事件。具体来说，在 Redis 中，客户端的请求是由⼀个单线程来处理的，⽽ IO 操作却是通过 epoll 多路复⽤技术实现的。")]),v._v(" "),_("h2",{attrs:{id:"mysql篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql篇"}},[v._v("#")]),v._v(" MySQL篇")]),v._v(" "),_("h3",{attrs:{id:"如何定位慢查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何定位慢查询"}},[v._v("#")]),v._v(" 如何定位慢查询？")]),v._v(" "),_("p",[v._v("慢查询一般发生在如下查询场景：")]),v._v(" "),_("ul",[_("li",[v._v("聚合查询")]),v._v(" "),_("li",[v._v("多表查询")]),v._v(" "),_("li",[v._v("表数据量过大查询")]),v._v(" "),_("li",[v._v("深度分页查询")])]),v._v(" "),_("blockquote",[_("p",[v._v("表象：页面加载过慢、接口压测响应时间大于一秒")])]),v._v(" "),_("p",[v._v("方案一：使用开源工具")]),v._v(" "),_("p",[v._v("方案二：MySQL自带的慢日志查询")]),v._v(" "),_("p",[v._v("需要我们手动配置来开启慢日志查询。配置如下：")]),v._v(" "),_("div",{staticClass:"language-sh extra-class"},[_("pre",{pre:!0,attrs:{class:"language-sh"}},[_("code",[_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 开启慢日志查询")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[v._v("slow_query_log")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会被视为慢查询，记录慢查询日志")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token assign-left variable"}},[v._v("long_query_time")]),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("2")]),v._v("\n")])])]),_("p",[v._v("配置完毕后重启，当有慢查询的时候，就会在"),_("code",[v._v("/var/lib/mysql/localhost-slow.log")]),v._v("中记录查询超过2秒的sql")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308240949323.png",alt:"image-20230824094928081"}})]),v._v(" "),_("blockquote",[_("p",[v._v("我们在MySQL中开启了慢日志查询，我们设置的值是2秒钟，一旦sql执行超过了我们设置的2秒钟就会被记录到日志中。(调试阶段)")])]),v._v(" "),_("h3",{attrs:{id:"如何分析慢查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何分析慢查询"}},[v._v("#")]),v._v(" 如何分析慢查询？")]),v._v(" "),_("p",[v._v("在sql查询语句前面加上explain关键字可以对该查询sql进行分析，得到一张表如下：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308240958475.png",alt:"image-20230824095849403"}})]),v._v(" "),_("p",[v._v("其中我们主要关注的有：")]),v._v(" "),_("ul",[_("li",[v._v("possible_keys：当前sql可能使用到的索引")]),v._v(" "),_("li",[v._v("key：当前sql实际命中的索引")]),v._v(" "),_("li",[v._v("key_len：当前索引占用的大小")]),v._v(" "),_("li",[v._v("Extra：额外的优化的建议")])]),v._v(" "),_("blockquote",[_("p",[v._v("我们可以通过key和key_len判断是否命中索引")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("type：sql的连接的类型，性能由好到差为：NULL、system、const、eq_ref、ref、range、index、all")]),v._v(" "),_("ul",[_("li",[v._v("NULL：查询中没有表")]),v._v(" "),_("li",[v._v("system：查询MySQL内置自带的表")]),v._v(" "),_("li",[v._v("const：根据主键索引查询")]),v._v(" "),_("li",[v._v("eq_ref：根据主键索引查询或者唯一索引查询(只能返回一条数据，因为主键和唯一索引不能重复)")]),v._v(" "),_("li",[v._v("ref：索引查询(可能返回多条数据)")]),v._v(" "),_("li",[v._v("range：范围查询")]),v._v(" "),_("li",[v._v("index：索引树扫描")]),v._v(" "),_("li",[v._v("all：全盘扫描")])]),v._v(" "),_("blockquote",[_("p",[v._v("如果某个sql的type是index或者是all那么这个sql就需要优化")])])])]),v._v(" "),_("h3",{attrs:{id:"了解过索引吗-什么是索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#了解过索引吗-什么是索引"}},[v._v("#")]),v._v(" 了解过索引吗？(什么是索引)")]),v._v(" "),_("p",[v._v("索引(index)是帮助MySQL"),_("strong",[v._v("高效获取数据")]),v._v("的"),_("strong",[v._v("数据结构")]),v._v("。在数据之外，数据库系统维护了满足特定查找算法的数据结构(B+树)，这些数据结构以某种方式引用数据，这样就可以在这些数据结构上实现高效的查找算法，这种数据结构就是索引。")]),v._v(" "),_("h3",{attrs:{id:"索引的底层数据结构是什么样的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引的底层数据结构是什么样的"}},[v._v("#")]),v._v(" 索引的底层数据结构是什么样的？")]),v._v(" "),_("p",[v._v("索引底层的数据结构是B+树，B+Tree是在BTree的基础上的一种优化，"),_("strong",[v._v("非叶子节点上只存储指针不存储数据，叶子节点上真正的存储数据，并且叶子节点之间使用双向指针相互连接")]),v._v("，innoDB存储引擎使用的就是B+树实现索引的")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241032008.png",alt:"image-20230824103228853"}})]),v._v(" "),_("p",[v._v("B+树相对于B树的优点：")]),v._v(" "),_("ul",[_("li",[v._v("磁盘读写代价B+树更低。比如我们需要查找6对应的数据，如果是B树因为B树的每个节点下的键值都由数据，会导致不需要的数据也会被读取到造成磁盘读写的浪费，而B+树只有叶子节点上保存数据，非叶子节点上保存的是指针，可以避免读取到不需要的数据")]),v._v(" "),_("li",[v._v("查询效率B+树稳定。因为非叶子节点上没有数据，每次查找都会从根节点出发直到叶子结点，所以查询的效率更稳定")]),v._v(" "),_("li",[v._v("B+树更适合区间查询，因为B+树的叶子节点使用双向指针相互连接，比如查询6-36之间的数据只需要查找到6然后根据指针来进行查找即可。")])]),v._v(" "),_("h3",{attrs:{id:"什么是聚簇索引-聚集索引-什么是非聚簇索引-非聚集索引、二级索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是聚簇索引-聚集索引-什么是非聚簇索引-非聚集索引、二级索引"}},[v._v("#")]),v._v(" 什么是聚簇索引(聚集索引)什么是非聚簇索引(非聚集索引、二级索引)？")]),v._v(" "),_("p",[v._v("聚集索引：将数据与索引放到一块，索引结构的叶子结点保存了行数据；特点是索引必须有对应的整行数据并且只有一个。一般主键作为聚集索引。")]),v._v(" "),_("p",[v._v("二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键；特点是 索引结构的叶子节点关联的的主键 可以有多个。一般自定义的索引都是二级索引")]),v._v(" "),_("p",[v._v("聚集索引的选举规则：")]),v._v(" "),_("ul",[_("li",[v._v("如果存在主键，主键索引就是聚集索引。")]),v._v(" "),_("li",[v._v("如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引。")]),v._v(" "),_("li",[v._v("如果表没有主键，或者没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241507824.png",alt:"image-20230824150748657"}})]),v._v(" "),_("h3",{attrs:{id:"什么是回表查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是回表查询"}},[v._v("#")]),v._v(" 什么是回表查询？")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241516807.png",alt:"image-20230824151652643"}})]),v._v(" "),_("blockquote",[_("p",[v._v("select * from user where name = ‘Arm’;")]),v._v(" "),_("p",[v._v("由于name添加了索引，并且name不是主键也不是唯一索引而且表含有主键id，所以name就是二级索引，首先在二级索引中找到Arm对应的主键id，由于该sql语句查询的是*整行数据，所以需要再次查询聚集索引找到主键对应的整行数据。")]),v._v(" "),_("p",[v._v("综上回表查询就是：通过"),_("strong",[v._v("二级索引")]),v._v("查找到主键值，然后到"),_("strong",[v._v("聚集索引")]),v._v("中通过主键值查找到对应的整行数据，这个过程就是回表查询。")])]),v._v(" "),_("h3",{attrs:{id:"什么是覆盖索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是覆盖索引"}},[v._v("#")]),v._v(" 什么是覆盖索引？")]),v._v(" "),_("blockquote",[_("p",[v._v("覆盖索引：指查询使用了索引，并且需要返回的列 在该索引中已经全部能够找到。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241545300.png",alt:"image-20230824154526112"}})]),v._v(" "),_("h3",{attrs:{id:"mysql超大分页处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql超大分页处理"}},[v._v("#")]),v._v(" MySQL超大分页处理")]),v._v(" "),_("blockquote",[_("p",[v._v("在数据量比较大的时候，如果进行limit分页查询，在查询时候，越靠后分页查询的效率就越低。")])]),v._v(" "),_("p",[v._v("例如 "),_("code",[v._v("select * from tb_user limit 9000000, 10;")]),v._v("需要耗时10秒多，因为执行的时候MySQL需要排序前9000010记录，但是仅仅返回9000000 - 9000010 条的记录，其他的记录丢弃，查询排序的代价非常大。")]),v._v(" "),_("p",[v._v("使用 覆盖索引+子查询 形式进行优化")]),v._v(" "),_("div",{staticClass:"language-mysql extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("select *\nfrom tb_user u,\n\t(select id from tb_user order by id limit 9000000,10) a # 根据id排序和返回id直接走的是覆盖索引\nwhere u.id = a.id;\n")])])]),_("p",[v._v("先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了。因为查询id的时候，走的覆盖索引，所以效率可以提升很多")]),v._v(" "),_("h3",{attrs:{id:"创建索引的原则有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#创建索引的原则有哪些"}},[v._v("#")]),v._v(" 创建索引的原则有哪些？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("数据量大，查询频繁的字段。")]),v._v(" "),_("p",[v._v("表中的数据要超过10万以上，我们才会创建索引，并且添加索引的字段是查询比较频繁的字段，一般也是像作为"),_("strong",[v._v("查询条件where，排序字段order by或分组group的字段")]),v._v("这些。")])]),v._v(" "),_("li",[_("p",[v._v("尽量选择区分度较高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率就越高。(例如性别和城市就不适合作为索引，因为会有大量重复的数据，区分度不高)")])]),v._v(" "),_("li",[_("p",[v._v("如果是字符串类型的字段，并且该字段比较长，可以针对该字段创建"),_("strong",[v._v("前缀索引")]),v._v("(只截取前面几个字符串来创建索引)")])])]),v._v(" "),_("h3",{attrs:{id:"什么情况下索引会失效"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下索引会失效"}},[v._v("#")]),v._v(" 什么情况下索引会失效？")]),v._v(" "),_("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241658008.png",alt:"image-20230824165808831"}}),v._v(" "),_("ul",[_("li",[_("p",[v._v("违反最左前缀法则")]),v._v(" "),_("p",[v._v("如果索引了多列，要遵循最左前缀法则。意思是查询必须从索引的最左前列开始，并且不能跳过索引中的列。")]),v._v(" "),_("p",[v._v("匹配最左前缀法则，走索引的案例：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241658519.png",alt:"image-20230824165829433"}})]),v._v(" "),_("p",[v._v("违反最左前缀，索引失效的案例：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241701612.png",alt:"image-20230824170127494"}})]),v._v(" "),_("p",[v._v("如果符合最左法则，但是出现跳过某一列，只有最左索引生效(只命中了name一个索引)")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241703372.png",alt:"image-20230824170318295"}})])]),v._v(" "),_("li",[_("p",[v._v("范围查询右边的列会索引失效。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241706249.png",alt:"image-20230824170601060"}})]),v._v(" "),_("blockquote",[_("p",[v._v("范围查询右边的address的索引会失效，所以上面的查询只命中了name和status两个索引")])])]),v._v(" "),_("li",[_("p",[v._v("不要在索引的字段上进行运算操作，否则索引将会失效。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241711772.png",alt:"image-20230824171108620"}})])]),v._v(" "),_("li",[_("p",[v._v("字符串不加单引号，可能造成索引失效")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241712862.png",alt:"image-20230824171229791"}})]),v._v(" "),_("blockquote",[_("p",[v._v("在查询的时候没有对字符串的status加上单引号，MySQL的查询会自动进行类型转换，造成索引失效。")])])]),v._v(" "),_("li",[_("p",[v._v("以%开头的Like模糊查询，导致索引失效。如果仅仅是尾部模糊匹配，索引不会失效；如果是头部模糊匹配，索引会失效。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241715986.png",alt:"image-20230824171513907"}})])])]),v._v(" "),_("blockquote",[_("p",[v._v("综上：什么情况下会导致索引失效？")]),v._v(" "),_("ul",[_("li",[v._v("违反了最左前缀法则")]),v._v(" "),_("li",[v._v("范围查询的右边的列，不能使用索引，因为索引失效了")]),v._v(" "),_("li",[v._v("索引列上进行运算操作")]),v._v(" "),_("li",[v._v("字符串不加单引号(类型转换)")]),v._v(" "),_("li",[v._v("以%开头的模糊查询")])])]),v._v(" "),_("h3",{attrs:{id:"事务的特性是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务的特性是什么"}},[v._v("#")]),v._v(" 事务的特性是什么？")]),v._v(" "),_("p",[v._v("事务是一组操作的集合，它是一个不可分割的单位，事务会把所有的操作视为一个整体一起向系统提交或撤销操作的请求，这些操作要么同时成功，要么同时失败。")]),v._v(" "),_("p",[v._v("事务的特性是ACID：原子性、一致性、隔离性、持久性。")]),v._v(" "),_("ol",[_("li",[v._v("原⼦性（Atomicity）：事务是⼀个原⼦操作，要么全部提交，要么全部回滚。当⼀个事务执⾏期间发⽣故\n障，操作系统会⾃动将其回滚到事务执⾏之前的状态，保证数据的⼀致性。")]),v._v(" "),_("li",[v._v("⼀致性（Consistency）：事务执⾏结束后，数据必须保持⼀致性状态。在事务执⾏期间，数据库中的数据可\n以处于中间状态，但在事务完成时必须保证数据的⼀致性。")]),v._v(" "),_("li",[v._v("隔离性（Isolation）：数据库系统必须保证事务之间相互隔离，不会互相⼲扰。隔离级别不同，会影响到事务\n的并发性和数据⼀致性，⽐如出现脏读、不可重复读、幻读等问题。")]),v._v(" "),_("li",[v._v("持久性（Durability）：⼀旦事务提交，其所做的修改必须永久保存到数据库中。即使系统发⽣故障或宕机，\n数据也能够保持不变。")])]),v._v(" "),_("h3",{attrs:{id:"并发事务带来哪些问题-怎么解决-mysql默认的隔离级别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发事务带来哪些问题-怎么解决-mysql默认的隔离级别是什么"}},[v._v("#")]),v._v(" 并发事务带来哪些问题？怎么解决？MySQL默认的隔离级别是什么？")]),v._v(" "),_("blockquote",[_("p",[v._v("并发事务会导致的问题有：脏读，不可重复读，幻读，丢失更新。")]),v._v(" "),_("p",[v._v("MySQL的隔离级别有：读未提交，读已提交，"),_("strong",[v._v("可重复读")]),v._v("，串行化")])]),v._v(" "),_("p",[v._v("并发事务的问题：")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241742624.png",alt:"image-20230824174214437"}})]),v._v(" "),_("p",[v._v("解决方法：对事务进行隔离")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308241743208.png",alt:"image-20230824174356130"}})]),v._v(" "),_("h3",{attrs:{id:"undo-log和redo-log的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#undo-log和redo-log的区别"}},[v._v("#")]),v._v(" undo log和redo log的区别")]),v._v(" "),_("p",[v._v("redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据，而undo log 不同，它主要记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据，比如我们删除一条数据的时候，就会在undo log日志文件中新增一条delete语句，如果发生回滚就执行逆操作；")]),v._v(" "),_("p",[v._v("redo log保证了事务的持久性，undo log保证了事务的原子性和一致性")]),v._v(" "),_("h3",{attrs:{id:"事务中的隔离性是如何保证的呢-解释一下mvcc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务中的隔离性是如何保证的呢-解释一下mvcc"}},[v._v("#")]),v._v(" 事务中的隔离性是如何保证的呢？(解释一下MVCC)")]),v._v(" "),_("p",[v._v("事务的隔离性是由锁和mvcc实现的。")]),v._v(" "),_("blockquote",[_("p",[v._v("锁：排它锁(一个事务获取了一个数据行的排它锁，其他事务就不能再获取该行的其他锁)")]),v._v(" "),_("p",[v._v("mvcc：多版本并发控制")]),v._v(" "),_("p",[v._v("MVCC的具体实现主要依赖于数据库中记录的"),_("strong",[v._v("隐藏字段、undo log日志、readView")]),v._v("。")]),v._v(" "),_("p",[v._v("隐藏字段是指：在mysql中给每个表都设置了隐藏字段，有一个是trx_id(事务id)，记录每一次操作的事务id，是自增的；另一个字段是roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址")]),v._v(" "),_("p",[v._v("undo log主要的作用是记录回滚日志，存储老版本数据，在内部会形成一个版本链，在多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表")]),v._v(" "),_("p",[v._v("readView(读视图)解决的是一个事务查询选择版本的问题，在内部定义了一些匹配规则和当前的一些事务id判断该访问那个版本的数据，不同的隔离级别快照读是不一样的，最终的访问的结果不一样。如果是rc隔离级别，每一次执行快照读时生成ReadView，如果是rr隔离级别仅在事务中第一次执行快照读时生成ReadView，后续复用")])]),v._v(" "),_("h3",{attrs:{id:"mysql主从同步原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql主从同步原理"}},[v._v("#")]),v._v(" MySQL主从同步原理")]),v._v(" "),_("blockquote",[_("p",[v._v("MySQL主从复制的核心就是二进制日志(BINLOG)中记录了DDL（数据定义语言）语句和 DML（数据操纵语言）语句)，它的步骤是这样的：")]),v._v(" "),_("p",[v._v("第一：主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。")]),v._v(" "),_("p",[v._v("第二：从库读取主库的二进制日志文件 Binlog ，写入到从库的"),_("strong",[v._v("中继日志")]),v._v(" (Relay Log )。")]),v._v(" "),_("p",[v._v("第三：从库重做中继日志中的事件，将改变反映它自己的数据")])]),v._v(" "),_("h3",{attrs:{id:"mysql的分库分表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql的分库分表"}},[v._v("#")]),v._v(" MySQL的分库分表")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308251948931.png",alt:"image-20230825194845740"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308251950497.png",alt:"image-20230825195028337"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308251952913.png",alt:"image-20230825195215716"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308251954945.png",alt:"image-20230825195410827"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202308251954941.png",alt:"image-20230825195454723"}})]),v._v(" "),_("h2",{attrs:{id:"框架篇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#框架篇"}},[v._v("#")]),v._v(" 框架篇")]),v._v(" "),_("h3",{attrs:{id:"spring中的bean是线程安全的吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中的bean是线程安全的吗"}},[v._v("#")]),v._v(" Spring中的Bean是线程安全的吗？")]),v._v(" "),_("p",[v._v("Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。")]),v._v(" "),_("p",[v._v("我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。")]),v._v(" "),_("p",[v._v("prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。")]),v._v(" "),_("p",[v._v("不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。")]),v._v(" "),_("p",[v._v("对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：")]),v._v(" "),_("ol",[_("li",[v._v("在 Bean 中尽量避免定义可变的成员变量。")]),v._v(" "),_("li",[v._v("在类中定义一个 "),_("code",[v._v("ThreadLocal")]),v._v(" 成员变量，将需要的可变成员变量保存在 "),_("code",[v._v("ThreadLocal")]),v._v(" 中（推荐的一种方式）。")])]),v._v(" "),_("h3",{attrs:{id:"bean的作用域有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bean的作用域有哪些"}},[v._v("#")]),v._v(" Bean的作用域有哪些？")]),v._v(" "),_("p",[v._v("Spring 中 Bean 的作用域通常有下面几种：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("singleton")]),v._v(" : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。")]),v._v(" "),_("li",[_("strong",[v._v("prototype")]),v._v(" : 每次获取都会创建一个新的 bean 实例。也就是说，连续 "),_("code",[v._v("getBean()")]),v._v(" 两次，得到的是不同的 Bean 实例。")]),v._v(" "),_("li",[_("strong",[v._v("request")]),v._v(" （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。")]),v._v(" "),_("li",[_("strong",[v._v("session")]),v._v(" （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。")]),v._v(" "),_("li",[_("strong",[v._v("application/global-session")]),v._v(" （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。")]),v._v(" "),_("li",[_("strong",[v._v("websocket")]),v._v(" （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。")])]),v._v(" "),_("h3",{attrs:{id:"什么是aop-你的项目中有没有使用到aop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是aop-你的项目中有没有使用到aop"}},[v._v("#")]),v._v(" 什么是AOP？你的项目中有没有使用到AOP？")]),v._v(" "),_("blockquote",[_("p",[v._v("AOP 称为面向切面编程，用于将那些"),_("strong",[v._v("与业务无关")]),v._v(" 但却对多个对象产生影响的"),_("strong",[v._v("公共行为和逻辑")]),v._v("，抽取并且封装成一个可重用的模块，这个模块被命名为切面(Aspect)，"),_("strong",[v._v("减少系统中的重复代码，降低了模块之间的耦合度，同时提高了系统的可维护性。")])])]),v._v(" "),_("p",[v._v("我的项目中使用AOP来记录请求日志，校验登录用户是否是管理员(配合自定义注解authCheck中的mustRole必须是admin才可以执行方法)。")]),v._v(" "),_("p",[v._v("先来介绍一下项目中使用AOP记录请求日志：首先编写一个类并使用@Aspect和@Component注解来表示这是一个AOP类，再定义一个方法并且使用@Around注解来标识在注解中填写表达式或者是切入点的方法，这里我直接填写表达式为 "),_("code",[v._v("* com.panda.controller.*.*(..)")]),v._v(" 这个表达式可以匹配controller包中所有的方法，然后通过"),_("code",[v._v("RequestContextHolder")]),v._v("工具类来获取当前线程的Request相关的信息，获取Session得到当前的用户信息和请求的路径，记录请求日志。")]),v._v(" "),_("p",[v._v("校验当前用户是否是管理员使用AOP是在Around中写@annotation(authCheck)来拦截被authCheck注解标注的类，获取当前方法要求的用户权限，与该用户的角色进行判断，如果该用户是管理员则可以执行方法。")]),v._v(" "),_("h3",{attrs:{id:"spring中的事务是如何实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中的事务是如何实现的"}},[v._v("#")]),v._v(" Spring中的事务是如何实现的？")]),v._v(" "),_("blockquote",[_("p",[v._v("Spring中的事务也是通过AOP来实现的，Spring提供了两种事务的使用方法：编程式事务和声明式事务")])]),v._v(" "),_("p",[v._v("经常使用的是声明式事务，在类或者是方法上添加@Transactional注解来开启事务，Spring使用AOP在方法的前面开启事务，在执行方法完毕之后提交事务，如果方法出现异常则会回滚事务。所以Spring中的事务是通过AOP来实现的。")]),v._v(" "),_("h3",{attrs:{id:"spring中事务失效的场景有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中事务失效的场景有哪些"}},[v._v("#")]),v._v(" Spring中事务失效的场景有哪些？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("异常捕获处理")]),v._v(" "),_("blockquote",[_("p",[v._v("在添加事务注解的方法中自己捕获异常并且在捕获的cache中没有抛出异常则会导致 事务不知道出现了异常 导致事务失效。")]),v._v(" "),_("p",[v._v('解决方法：在cache中再次抛出异常throw new RuntimeException("异常");')])])]),v._v(" "),_("li",[_("p",[v._v("抛出检查异常")]),v._v(" "),_("blockquote",[_("p",[v._v("Spring默认只会回滚非检查异常运行时异常(检查异常：在方法上使用throws抛出异常)")]),v._v(" "),_("p",[v._v("解决方法：配置rollbackFor属性为Exception.class只要出现异常就会回滚")])])]),v._v(" "),_("li",[_("p",[v._v("非public方法")]),v._v(" "),_("blockquote",[_("p",[v._v("Spring为方法创建代理、添加事务通知的前提条件是该方法是public的")]),v._v(" "),_("p",[v._v("解决方法：把方法改为public")])])]),v._v(" "),_("li",[_("p",[v._v("同一个类里面调用(无法代理自己，可以通过AOP上下文对象(AopContext.currentProxy)获取一个当前类的代理类)")])])]),v._v(" "),_("h3",{attrs:{id:"spring的bean的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring的bean的生命周期"}},[v._v("#")]),v._v(" Spring的Bean的生命周期")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202309011033676.jpg",alt:"Spring Bean 生命周期"}})]),v._v(" "),_("blockquote",[_("ol",[_("li",[v._v("通过BeanDefinition获取bean的定义信息")]),v._v(" "),_("li",[v._v("调用构造函数实例化bean")]),v._v(" "),_("li",[v._v("bean的依赖注入(@Value、@Autowired...)")]),v._v(" "),_("li",[v._v("处理Aware接口(实现以Aware结尾的接口，里面有方法需要我们重写，执行这些方法)")]),v._v(" "),_("li",[_("code",[v._v("BeanPostProcessor")]),v._v("前置处理器")]),v._v(" "),_("li",[v._v("初始化方法(检查是否是InitializingBean、是否配置有自定义的init-method)")]),v._v(" "),_("li",[_("code",[v._v("BeanPostProcessor")]),v._v("后置处理器⭐️(可以在后置处理器中通过动态代理增强某个Bean)")]),v._v(" "),_("li",[v._v("销毁Bean")])])]),v._v(" "),_("h3",{attrs:{id:"spring中的循环引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring中的循环引用"}},[v._v("#")]),v._v(" Spring中的循环引用")]),v._v(" "),_("blockquote",[_("p",[v._v("两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A；循环依赖在spring中是允许存在，spring框架依据"),_("strong",[v._v("三级缓存")]),v._v("已经解决了大部分的循环依赖(set方法注入)")]),v._v(" "),_("p",[v._v("创建A对象调用构造函数生成一个半成品的A对象，在设置对象属性，发现对象属性中有B对象，那么创建B对象调用B对象的构造函数生成一个半成品的B对象然后初始化B对象发现B对象中有A对象需要到Spring容器中找A对象但是A对象并没有初始化完毕，所以造成了循环依赖。")])]),v._v(" "),_("p",[v._v("Spring解决循环依赖是通过三级缓存来解决的")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202309011105048.png",alt:"image-20230901110522841"}})]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("缓存名称")]),v._v(" "),_("th",[v._v("源码名称")]),v._v(" "),_("th",[v._v("作用")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("一级缓存")]),v._v(" "),_("td",[v._v("singletonObjects")]),v._v(" "),_("td",[v._v("单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象")])]),v._v(" "),_("tr",[_("td",[v._v("二级缓存")]),v._v(" "),_("td",[v._v("earlySingletonObjects")]),v._v(" "),_("td",[v._v("缓存早期的bean对象(生命周期还没有走完)")])]),v._v(" "),_("tr",[_("td",[v._v("三级缓存")]),v._v(" "),_("td",[v._v("singletonFactories")]),v._v(" "),_("td",[v._v("缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的")])])])]),v._v(" "),_("p",[v._v("①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象")]),v._v(" "),_("p",[v._v("②二级缓存：缓存早期的bean对象（生命周期还没走完）")]),v._v(" "),_("p",[v._v("③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的")]),v._v(" "),_("p",[v._v("具体流程：")]),v._v(" "),_("p",[v._v("第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories")]),v._v(" "),_("p",[v._v("第二，A在初始化的时候需要B对象，这个走B的创建的逻辑")]),v._v(" "),_("p",[v._v("第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories")]),v._v(" "),_("p",[v._v("第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键")]),v._v(" "),_("p",[v._v("第五，B通过从通过二级缓存earlySingletonObjects  获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects")]),v._v(" "),_("p",[v._v("第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一次缓存singletonObjects")]),v._v(" "),_("p",[v._v("第七，二级缓存中的临时对象A清除")]),v._v(" "),_("h3",{attrs:{id:"构造方法出现了循环依赖怎么解决"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构造方法出现了循环依赖怎么解决"}},[v._v("#")]),v._v(" 构造方法出现了循环依赖怎么解决？")]),v._v(" "),_("p",[v._v("由于bean的生命周期中"),_("strong",[v._v("构造函数是第一个执行的")]),v._v("，spring框架并不能解决构造函数的的依赖注入，可以使用@Lazy懒加载，什么时候需要对象再进行bean对象的创建")]),v._v(" "),_("h3",{attrs:{id:"springmvc的执行流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springmvc的执行流程"}},[v._v("#")]),v._v(" SpringMVC的执行流程")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202309011717921.png",alt:"img"}})]),v._v(" "),_("p",[v._v("客户端（浏览器）发送请求， "),_("code",[v._v("DispatcherServlet")]),v._v("拦截请求。")]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[_("code",[v._v("DispatcherServlet")]),v._v(" 根据请求信息调用 "),_("code",[v._v("HandlerMapping")]),v._v(" 。"),_("code",[v._v("HandlerMapping")]),v._v(" 根据 uri 去匹配查找能处理的 "),_("code",[v._v("Handler")]),v._v("（也就是我们平常说的 "),_("code",[v._v("Controller")]),v._v(" 控制器） ，并会将请求涉及到的拦截器和 "),_("code",[v._v("Handler")]),v._v(" 一起封装。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("DispatcherServlet")]),v._v(" 调用 "),_("code",[v._v("HandlerAdapter")]),v._v("适配器执行 "),_("code",[v._v("Handler")]),v._v(" 。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("Handler")]),v._v(" 完成对用户请求的处理后，会返回一个 "),_("code",[v._v("ModelAndView")]),v._v(" 对象给"),_("code",[v._v("DispatcherServlet")]),v._v("，"),_("code",[v._v("ModelAndView")]),v._v(" 顾名思义，包含了数据模型以及相应的视图的信息。"),_("code",[v._v("Model")]),v._v(" 是返回的数据对象，"),_("code",[v._v("View")]),v._v(" 是个逻辑上的 "),_("code",[v._v("View")]),v._v("。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("ViewResolver")]),v._v(" 会根据逻辑 "),_("code",[v._v("View")]),v._v(" 查找实际的 "),_("code",[v._v("View")]),v._v("。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("DispaterServlet")]),v._v(" 把返回的 "),_("code",[v._v("Model")]),v._v(" 传给 "),_("code",[v._v("View")]),v._v("（视图渲染）。")])]),v._v(" "),_("li",[_("p",[v._v("把 "),_("code",[v._v("View")]),v._v(" 返回给请求者（浏览器）")])])]),v._v(" "),_("h3",{attrs:{id:"spring-mvc-的核心组件有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc-的核心组件有哪些"}},[v._v("#")]),v._v(" Spring MVC 的核心组件有哪些？")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[_("code",[v._v("DispatcherServlet")])]),v._v("："),_("strong",[v._v("核心的中央处理器")]),v._v("，负责接收请求、分发，并给予客户端响应。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("HandlerMapping")])]),v._v("："),_("strong",[v._v("处理器映射器")]),v._v("，根据 uri 去匹配查找能处理的 "),_("code",[v._v("Handler")]),v._v(" ，并会将请求涉及到的拦截器和 "),_("code",[v._v("Handler")]),v._v(" 一起封装。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("HandlerAdapter")])]),v._v("："),_("strong",[v._v("处理器适配器")]),v._v("，根据 "),_("code",[v._v("HandlerMapping")]),v._v(" 找到的 "),_("code",[v._v("Handler")]),v._v(" ，适配执行对应的 "),_("code",[v._v("Handler")]),v._v("；")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("Handler")])]),v._v("："),_("strong",[v._v("请求处理器")]),v._v("，处理实际请求的处理器。")])]),v._v(" "),_("li",[_("p",[_("strong",[_("code",[v._v("ViewResolver")])]),v._v("："),_("strong",[v._v("视图解析器")]),v._v("，根据 "),_("code",[v._v("Handler")]),v._v(" 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 "),_("code",[v._v("DispatcherServlet")]),v._v(" 响应客户端")])])]),v._v(" "),_("h3",{attrs:{id:"springboot的自动配置原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springboot的自动配置原理"}},[v._v("#")]),v._v(" SpringBoot的自动配置原理")]),v._v(" "),_("p",[v._v("在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("@SpringBootConfiguration")])]),v._v(" "),_("li",[_("p",[v._v("@EnableAutoConfiguration")])]),v._v(" "),_("li",[_("p",[v._v("@ComponentScan")])])]),v._v(" "),_("p",[v._v("其中"),_("code",[v._v("@EnableAutoConfiguration")]),v._v("是实现自动化配置的核心注解。")]),v._v(" "),_("p",[v._v("该注解通过"),_("code",[v._v("@Import")]),v._v("注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的Jar包的的classpath路径下"),_("strong",[v._v("META-INF/spring.factories")]),v._v("文件中的所配置的类的全类名。")]),v._v(" "),_("p",[v._v("在这些配置类中所定义的Bean会根据条件注解所"),_("strong",[v._v("指定的条件来决定")]),v._v("是否需要将其导入到Spring容器中。")]),v._v(" "),_("p",[v._v("一般条件判断会有像"),_("code",[v._v("@ConditionalOnClass")]),v._v("这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。")]),v._v(" "),_("h3",{attrs:{id:"spring-spring-mvc-springboot-常用注解有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-spring-mvc-springboot-常用注解有哪些"}},[v._v("#")]),v._v(" Spring && Spring MVC && SpringBoot 常用注解有哪些？")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202309011733641.png",alt:"image-20230901173331454"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202309011734522.png",alt:"image-20230901173457417"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"https://blog-images-1309758663.cos.ap-nanjing.myqcloud.com/202309011737694.png",alt:"image-20230901173707590"}})]),v._v(" "),_("blockquote",[_("p",[v._v("https://javaguide.cn/system-design/framework/spring/spring-common-annotations.html")])]),v._v(" "),_("h3",{attrs:{id:"mybatis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mybatis"}},[v._v("#")]),v._v(" MyBatis")]),v._v(" "),_("blockquote",[_("p",[v._v("https://javaguide.cn/system-design/framework/mybatis/mybatis-interview.html")])]),v._v(" "),_("h3",{attrs:{id:"项目中使用的spring-cloud组件有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#项目中使用的spring-cloud组件有哪些"}},[v._v("#")]),v._v(" 项目中使用的Spring Cloud组件有哪些？")]),v._v(" "),_("ul",[_("li",[v._v("注册中心和配置中心：nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。")]),v._v(" "),_("li",[v._v("RPC远程调用框架：Dubbo")]),v._v(" "),_("li",[v._v("网关：Spring Cloud Gateway：用于网关服务，实现请求的转发和路由。")]),v._v(" "),_("li",[v._v("服务保护：Sentinel(在项目中暂时没有使用到)以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。")])]),v._v(" "),_("h3",{attrs:{id:"服务注册和发现是什么意思-spring-cloud如何实现服务注册发现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务注册和发现是什么意思-spring-cloud如何实现服务注册发现"}},[v._v("#")]),v._v(" 服务注册和发现是什么意思？Spring Cloud如何实现服务注册发现？")]),v._v(" "),_("p",[v._v("服务注册：服务提供者需要把自己的信息注册到注册中心中，由注册中心来保存这些信息，比如服务名称、ip、端口等等")]),v._v(" "),_("p",[v._v("服务发现：消费者向注册中心拉取服务列表信息，如果服务的提供者有集群，则消费者会使用负载均衡选择一个服务发起调用")]),v._v(" "),_("p",[v._v("服务监控：服务提供者会每隔一段时间向注册中心发送心跳，汇报健康状态，如果注册中心超过一定的时间没有收到心跳则会被剔除掉")]),v._v(" "),_("h3",{attrs:{id:"nacos和eureka的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nacos和eureka的区别"}},[v._v("#")]),v._v(" nacos和Eureka的区别")]),v._v(" "),_("p",[v._v("api平台项目就是采用的nacos作为注册中心，选择nacos还要一个重要原因就是它支持配置中心，不过nacos作为注册中心，也比eureka要方便好用一些，主要相同不同点在于几点：")]),v._v(" "),_("ul",[_("li",[v._v("共同点")])]),v._v(" "),_("p",[v._v("Nacos与eureka都支持服务注册和服务拉取，都支持服务提供者心跳方式做健康检测")]),v._v(" "),_("ul",[_("li",[v._v("Nacos与Eureka的区别")])]),v._v(" "),_("p",[v._v("①Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式")]),v._v(" "),_("p",[v._v("②临时实例心跳不正常会被剔除，非临时实例则不会被剔除")]),v._v(" "),_("p",[v._v("③Nacos支持服务列表变更的消息推送模式，服务列表更新更及时")]),v._v(" "),_("p",[v._v("④Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式")]),v._v(" "),_("h3",{attrs:{id:"什么是cap理论"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是cap理论"}},[v._v("#")]),v._v(" 什么是CAP理论？")]),v._v(" "),_("p",[v._v("CAP主要是在分布式项目下的一个理论。包含了三项，一致性、可用性、分区容错性")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("一致性(Consistency)是指更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致(强一致性)，不能存在中间状态。")])]),v._v(" "),_("li",[_("p",[v._v("可用性(Availability) 是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。")])]),v._v(" "),_("li",[_("p",[v._v("分区容错性(Partition tolerance) 是指分布式系统在遇到任何网络分区故障时，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。")])])]),v._v(" "),_("h2",{attrs:{id:"消息队列"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[v._v("#")]),v._v(" 消息队列")]),v._v(" "),_("h3",{attrs:{id:"rabbitmq如何保证消息不丢失"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq如何保证消息不丢失"}},[v._v("#")]),v._v(" RabbitMQ如何保证消息不丢失？")]),v._v(" "),_("p",[v._v("主要从三个层面考虑")]),v._v(" "),_("p",[v._v("第一个是开启生产者确认机制，确保生产者的消息能到达队列，如果报错可以先记录到日志中，再去修复数据")]),v._v(" "),_("p",[v._v("第二个是开启持久化功能，确保消息未消费前在队列中不会丢失，其中的交换机、队列、和消息都要做持久化")]),v._v(" "),_("p",[v._v("第三个是开启消费者确认机制为auto，由spring确认消息处理成功后完成ack，当然也需要设置一定的重试次数，我们当时设置了3次，如果重试3次还没有收到消息，就将失败后的消息投递到异常交换机，交由人工处理。")]),v._v(" "),_("h3",{attrs:{id:"rabbitmq消息的重复消费问题如何解决的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq消息的重复消费问题如何解决的"}},[v._v("#")]),v._v(" RabbitMQ消息的重复消费问题如何解决的？")]),v._v(" "),_("p",[v._v("消费者设置了自动确认机制，当服务还没来得及给MQ确认的时候，服务宕机了，导致服务重启之后，又消费了一次消息。这样就重复消费了")]),v._v(" "),_("p",[v._v("因为我们当时处理的支付（订单|业务唯一标识），它有一个业务的唯一标识，我们再处理消息时，先到数据库查询一下，这个数据是否存在，如果不存在，说明没有处理过，这个时候就可以正常处理这个消息了。如果已经存在这个数据了，就说明消息重复消费了，我们就不需要再消费了")]),v._v(" "),_("h3",{attrs:{id:"消息队列可以用来干什么-在你的项目中有使用到吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列可以用来干什么-在你的项目中有使用到吗"}},[v._v("#")]),v._v(" 消息队列可以用来干什么，在你的项目中有使用到吗？")]),v._v(" "),_("p",[v._v("异步、解耦、削峰")]),v._v(" "),_("p",[v._v("在我曾经的一个项目中有主要使用到消息队列的异步的特性，当时是一个秒杀优惠券的功能，为了提高秒杀的性能 我使用到了redis缓存优惠券的库存，并且配合Lua脚本实现操作redis的原子性，在判断库存充足的情况下，会减少库存之后就向消息队列中发送下单优惠券的消息，然后就直接返回下单成功，消息的订阅者就监听消息队列发现有消息则执行具体的下单操作修改数据库的信息，完成下单的完整操作实现业务的异步，提高接口的响应速度。")]),v._v(" "),_("blockquote",[_("p",[v._v("引入消息队列可能会对系统造成的影响：")]),v._v(" "),_("p",[v._v("可用性降低，复杂度上升，又带来一系列的重复消费，顺序消费，分布式事务，消息堆积的问题。这些都有对应的解决方案")])])])}),[],!1,null,null,null);_.default=t.exports}}]);